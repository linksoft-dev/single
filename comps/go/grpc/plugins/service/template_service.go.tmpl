// Code generated by protoc-. DO NOT EDIT.
// versions:
// source:

package pb

import (
	"context"
	"github.com/linksoft-dev/single/comps/go/dao"
	"github.com/linksoft-dev/single/comps/go/str"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"strings"
	"fmt"
)

type {{.MessageName}}Server struct {
	Unimplemented{{.MessageName}}ServiceServer
	dao dao.Crud[{{.MessageName}}]
}

func New{{.MessageName}}Server(dao dao.Crud[{{.MessageName}}]) {{.MessageName}}Server {
	return {{.MessageName}}Server{dao: dao}
}

func (s *{{.MessageName}}Server) Create(ctx context.Context, req *Create{{.MessageName}}Request) (*Create{{.MessageName}}Response, error) {
	if req.{{.MessageName}} == nil {
		return nil, fmt.Errorf("required parameter {{.MessageName}} not passed by parameter")
	}

    v := InputParse{{.MessageName}}(*req.{{.MessageName}})
	if err := Validate{{.MessageName}}(ctx, *req.{{.MessageName}}); err != nil {
    		return nil, err
  	}
	r, err := s.dao.Create(v)
	if err != nil {
		return nil, err
	}
	v = FormatOutput{{.MessageName}}(v)
	return &Create{{.MessageName}}Response{ {{.MessageName}}: &r}, nil
}

func (s *{{.MessageName}}Server) Update(ctx context.Context, req *Update{{.MessageName}}Request) (*Update{{.MessageName}}Response, error) {
	if req.{{.MessageName}} == nil {
		return nil, fmt.Errorf("required parameter {{.MessageName}} not passed by parameter")
	}

	v := InputParse{{.MessageName}}(*req.{{.MessageName}})
	var fieldMask fieldmaskpb.FieldMask
	if req.UpdateMask == nil {
		fieldMask = fieldmaskpb.FieldMask{}
	} else {
		fieldMask = *req.UpdateMask
	}
	if err := Validate{{.MessageName}}(ctx, v); err != nil {
    	return nil, err
   	}
	err := s.dao.Update(v, fieldMask.Paths)
	if err != nil {
		return nil, err
	}
	v = FormatOutput{{.MessageName}}(v)
	return &Update{{.MessageName}}Response{ {{.MessageName}}: req.{{.MessageName}} }, nil
}

func (s *{{.MessageName}}Server) Delete(ctx context.Context, req *Delete{{.MessageName}}Request) (*Delete{{.MessageName}}Response, error) {
	if req.Id == "" {
		return nil, fmt.Errorf("id is required for delete process")
	}
	r, err := s.dao.Get(req.Id)
	if err != nil {
		return nil, err
	}

	err = s.dao.Delete(r)
	if err != nil {
		return nil, err
	}
	return &Delete{{.MessageName}}Response{}, nil
}

func (s *{{.MessageName}}Server) Find(ctx context.Context, req *Find{{.MessageName}}Request) (*Find{{.MessageName}}Response, error) {
	list, err := s.dao.Find(ctx, req.Filter)
	if err != nil {
		return nil, err
	}
	return &Find{{.MessageName}}Response{ {{.MessageName}}s: {{.MessageName}}ToPointOfSlice(list)}, nil
}


// GetId this method implements the interface dao.Crud
func (c {{.MessageName}}) GetId()string {
	return c.Name
}

// inputParse{{.MessageName}} perform some transformation/normalization over the object for type {{.MessageName}}
func InputParse{{.MessageName}}(v {{.MessageName}}) {{.MessageName}} {
{{ range $idx, $field := .Fields }}
  {{ $fieldName := toCamel $field.Field.Name.String }}
  {{ if or (eq $field.Settings.GetUpperCase.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName }} = strings.ToUpper(v.{{ $fieldName }})
  {{ end }}
  {{ if or (eq $field.Settings.GetTrimSpace.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName  }} = str.RemoveExtraSpaces(v.{{ $fieldName  }})
  {{ end }}
  {{ if or (eq $field.Settings.GetRemoveAccent.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName }} = str.RemoveAccent(v.{{ $fieldName }})
  {{ end }}
{{- end }}
return v
}

func FormatOutput{{.MessageName}}(v {{.MessageName}}) {{.MessageName}} {
    return v
}

// {{.MessageName}}ToPointOfSlice convert slice of {{.MessageName}} into slice of {{.MessageName}} pointers
func {{.MessageName}}ToPointOfSlice(slc []{{.MessageName}}) []*{{.MessageName}}{
	resp := make([]*{{.MessageName}}, len(slc))
	for i, c := range slc {
		resp[i] = &c
	}
	return resp
}

