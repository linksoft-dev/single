// Code generated by protoc-. DO NOT EDIT.
// versions:
// source:

package pb

import (
	"context"
	"errors"
	"fmt"
	"github.com/linksoft-dev/single/comps/go/dao"
	"github.com/linksoft-dev/single/comps/go/filter"
	"github.com/linksoft-dev/single/comps/go/str"
	"github.com/linksoft-dev/single/comps/go/validation"
	"google.golang.org/grpc/codes"
   	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"strings"
)

type {{.MessageName}}Server struct {
	Unimplemented{{.MessageName}}ServiceServer
	dao dao.Crud[*{{.MessageName}}]
	OnValidate func (ctx context.Context, validator *validation.Validation)
}

func New{{.MessageName}}Server(dao dao.Crud[*{{.MessageName}}]) *{{.MessageName}}Server {
	return &{{.MessageName}}Server{dao: dao}
}

func (s *{{.MessageName}}Server) Create(ctx context.Context, req *Create{{.MessageName}}Request) (*Create{{.MessageName}}Response, error) {
	if req.{{.MessageName}} == nil {
		return nil, fmt.Errorf("required parameter {{.MessageName}} not passed by parameter")
	}

    // validation
    v := InputParse{{.MessageName}}(*req.{{.MessageName}})
	validator := Validate{{.MessageName}}(ctx, *req.{{.MessageName}})
	if s.OnValidate !=nil {
   		s.OnValidate(ctx, validator)
  	}
   	if validator.Validated() == false {
   		return nil, validator
   	}

	r, err := s.dao.Create(ctx, &v)
	if err != nil {
		return nil, err
	}
	v = FormatOutput{{.MessageName}}(v)
	return &Create{{.MessageName}}Response{ {{.MessageName}}: r}, nil
}

func (s *{{.MessageName}}Server) Update(ctx context.Context, req *Update{{.MessageName}}Request) (*Update{{.MessageName}}Response, error) {
	if req.{{.MessageName}} == nil {
		return nil, fmt.Errorf("required parameter {{.MessageName}} not passed by parameter")
	}

	v := InputParse{{.MessageName}}(*req.{{.MessageName}})
	fieldMask := fieldmaskpb.FieldMask{}
    if req.UpdateMask != nil {
        fieldMask = *req.UpdateMask
    }

	// validation
    validator := Validate{{.MessageName}}(ctx, *req.{{.MessageName}})
    if s.OnValidate !=nil {
        s.OnValidate(ctx, validator)
    }
    if validator.Validated() == false {
        return nil, validator
    }

	err := s.dao.Update(ctx, &v, fieldMask.Paths)
	if err != nil {
	    if errors.Is(err, dao.ErrNotFound) {
            return nil, status.Error(codes.NotFound, err.Error())
        }
		return nil, status.Error(codes.Internal, err.Error())
	}
	v = FormatOutput{{.MessageName}}(v)
	return &Update{{.MessageName}}Response{ {{.MessageName}}: &v}, nil
}

func (s *{{.MessageName}}Server) Delete(ctx context.Context, req *Delete{{.MessageName}}Request) (*Delete{{.MessageName}}Response, error) {
	if req == nil || req.Id == "" {
	    return nil, status.Error(codes.InvalidArgument,"id is required for delete process")
	}

	err := s.dao.Delete(ctx, req.GetId())
	if err != nil {
    	if errors.Is(err, dao.ErrNotFound) {
    		return nil, status.Error(codes.NotFound, err.Error())
    	}
    	return nil, status.Error(codes.Internal, err.Error())
	}
	return &Delete{{.MessageName}}Response{}, nil
}

func (s *{{.MessageName}}Server) List(ctx context.Context, req *List{{.MessageName}}Request) (*List{{.MessageName}}Response, error) {
    if req == nil {
       req = &List{{.MessageName}}Request{}
    }
	list, err := s.dao.List(ctx, *req.Filter)
	if err != nil {
		return nil, err
	}
	return &List{{.MessageName}}Response{ {{.MessageName}}s: list}, nil
}

func (s *{{.MessageName}}Server) Get(ctx context.Context, req *Get{{.MessageName}}Request) (*Get{{.MessageName}}Response, error) {
    if req == nil {
       req = &Get{{.MessageName}}Request{}
    }
	list, err := s.dao.List(ctx, filter.Filter{Ids: []string{req.Id}})
	if err != nil {
		return nil, err
	}

	if list == nil || len(list) == 0 {
    	return nil, status.Error(codes.NotFound, "record not found")
    }
	return &Get{{.MessageName}}Response{ {{.MessageName}}: list[0]}, nil
}

// inputParse{{.MessageName}} perform some transformation/normalization over the object for type {{.MessageName}}
func InputParse{{.MessageName}}(v {{.MessageName}}) {{.MessageName}} {

    if v.Id == "" {
		v.Id = "{{ toLower .MessageName}}/"+str.Uuid()
	}

{{ range $idx, $field := .Fields }}
  {{ $fieldName := toCamel $field.Field.Name.String }}
  {{ if or (eq $field.Settings.GetUpperCase.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName }} = strings.ToUpper(v.{{ $fieldName }})
  {{ end }}
  {{ if or (eq $field.Settings.GetTrimSpace.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName  }} = str.RemoveExtraSpaces(v.{{ $fieldName  }})
  {{ end }}
  {{ if or (eq $field.Settings.GetRemoveAccent.String "YES") (eq $field.Settings.UpperNoSpaceNoAccent.String "YES") }}
    v.{{ $fieldName }} = str.RemoveAccent(v.{{ $fieldName }})
  {{ end }}
{{- end }}
return v
}

func FormatOutput{{.MessageName}}(v {{.MessageName}}) {{.MessageName}} {
    return v
}

// {{.MessageName}}ToPointOfSlice convert slice of {{.MessageName}} into slice of {{.MessageName}} pointers
func {{.MessageName}}ToPointOfSlice(slc []{{.MessageName}}) []*{{.MessageName}}{
	resp := make([]*{{.MessageName}}, len(slc))
	for i, c := range slc {
		resp[i] = &c
	}
	return resp
}
