package validate

import (
	"bytes"
	"embed"
	"fmt"
	pb "github.com/linksoft-dev/single/comps/go/grpc/plugins/validate/pb"
	"github.com/linksoft-dev/single/comps/go/obj"
	"github.com/linksoft-dev/single/comps/go/str"
	"github.com/linksoft-dev/single/comps/go/tpl"
	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
	log "github.com/sirupsen/logrus"
	"text/template"
)

//go:embed "template_validate.go.tmpl"
var templates embed.FS

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type module struct {
	*pgs.ModuleBase
	pgsgo.Context
	templatePath string
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &module{ModuleBase: &pgs.ModuleBase{}}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *module) Name() string { return "reporter" }

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *module) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}
	m.templatePath = m.Parameters().StrDefault("path", "./")

	for _, f := range targets {
		m.Push(f.Name().String()).Debug("reporting")
		for i, msg := range f.AllMessages() {
			m.generateValidation(msg, f)
			fmt.Fprintf(buf, "%03d. %v\n", i, msg.Name())
		}
		m.Pop()
	}

	return m.Artifacts()
}

func (m *module) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.Context = pgsgo.InitContext(c.Parameters())
}

type fieldSettings struct {
	Field       pgs.Field
	Type        string
	StringRules pb.StringRules
	FloatRules  pb.FloatRules
}

type message struct {
	MessageName string
	Fields      []fieldSettings
}

// generateCrud generate the crud file if proto message has crud option set to true
func (m *module) generateValidation(msg pgs.Message, f pgs.File) {

	fileName := m.Context.OutputPath(f).SetExt(".validate.go").String()
	data := message{
		MessageName: msg.Name().String(),
	}

	for _, f := range msg.Fields() {
		var rules pb.FieldRules
		_, err := f.Extension(pb.E_Rules, &rules)
		m.CheckErr(err, "unable to read validation rules from field")
		processFieldRules(&rules, f, &data)
	}

	if len(data.Fields) == 0 {
		return
	}
	data.Fields[0].Field.Type()
	funcMap := &template.FuncMap{
		"toCamel": str.ToCamel,
		"toInt":   obj.ToInt,
	}
	templateName := "template_validate.go.tmpl"

	r, err := tpl.RenderTemplate(templates, templateName, data, funcMap)
	if err != nil {
		log.WithError(err).Fatalf("failed when render template %s", templateName)
		return
	}

	m.AddGeneratorFile(fileName, r)
}

// processFieldRules this function convert the type into simple struct to be able to read the fields information easily
// specially, from Go templates
func processFieldRules(rules *pb.FieldRules, field pgs.Field, data *message) {
	if rules == nil {
		return
	}
	fs := fieldSettings{Field: field}

	switch r := rules.Type.(type) {
	case *pb.FieldRules_Float:
		fs.Type = "float"
		fs.FloatRules = *r.Float
	//case *pb.FieldRules_Double:
	//case *pb.FieldRules_Int32:
	//case *pb.FieldRules_Int64:
	//case *pb.FieldRules_Uint32:
	//case *pb.FieldRules_Uint64:
	//case *pb.FieldRules_Sint32:
	//case *pb.FieldRules_Sint64:
	//case *pb.FieldRules_Fixed32:
	//case *pb.FieldRules_Fixed64:
	//case *pb.FieldRules_Sfixed32:
	//case *pb.FieldRules_Sfixed64:
	//case *pb.FieldRules_Bool:
	case *pb.FieldRules_String_:
		fs.Type = "string"
		fs.StringRules = *r.String_
	//case *pb.FieldRules_Bytes:
	//case *pb.FieldRules_Enum:
	//case *pb.FieldRules_Repeated:
	//case *pb.FieldRules_Map:
	//case *pb.FieldRules_Any:
	//case *pb.FieldRules_Duration:
	//case *pb.FieldRules_Timestamp:
	case nil:
		return
	default:
		return
	}
	data.Fields = append(data.Fields, fs)
}

func processStringRules(field pgs.Field, msg *message) {
	stringRule := pb.StringRules{}
	ok, err := field.Extension(pb.E_Rules, &stringRule)
	if err != nil {
		log.WithError(err).Warnf("error when try to check if proto field has field settings")
	}

	// define default values
	if ok {
		msg.Fields = append(msg.Fields, fieldSettings{Field: field, StringRules: stringRule})
	}
}
