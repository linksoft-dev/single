package validate

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/linksoft-dev/single/comps/go/grpc/plugins/validate/pb"
	"github.com/linksoft-dev/single/comps/go/tpl"
	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
	log "github.com/sirupsen/logrus"
)

//go:embed "template_validate.go.tmpl"
var templates embed.FS

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
	pgsgo.Context
	templatePath string
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{ModuleBase: &pgs.ModuleBase{}}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string { return "reporter" }

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}
	m.templatePath = m.Parameters().StrDefault("path", "./")

	for _, f := range targets {
		m.Push(f.Name().String()).Debug("reporting")
		for i, msg := range f.AllMessages() {
			m.generateValidation(msg, f)
			fmt.Fprintf(buf, "%03d. %v\n", i, msg.Name())
		}
		m.Pop()
	}

	return m.Artifacts()
}

func (m *reportModule) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.Context = pgsgo.InitContext(c.Parameters())
}

type fieldSettings struct {
	Field       pgs.Field
	StringRules pb.StringRules
}

type message struct {
	MessageName string
	Fields      []fieldSettings
}

// generateCrud generate the crud file if proto message has crud option set to true
func (m *reportModule) generateValidation(msg pgs.Message, f pgs.File) {
	var v bool
	_, err := msg.Extension(pb.E_Rules, &v)
	if err != nil {
		log.WithError(err).Warnf("error when try to check if message has Rules flag")
	}
	if v == false {
		return
	}

	fileName := m.Context.OutputPath(f).SetExt(".validation.go").String()

	data := message{
		MessageName: msg.Name().String(),
	}
	// check all fields settings
	for _, field := range msg.Fields() {
		// perform the parse into Field object, this is the way to check the options present in each proto field about Field settings
		processStringRules(field, &data)
	}

	templateName := "template_validate.go.tmpl"
	r, err := tpl.RenderTemplate(templates, templateName, data, nil)
	if err != nil {
		log.WithError(err).Fatalf("failed when render template %s", templateName)
		return
	}

	m.AddGeneratorFile(fileName, r)
}

func processStringRules(field pgs.Field, msg *message) {
	stringRule := pb.StringRules{}
	ok, err := field.Extension(pb.E_Rules, &stringRule)
	if err != nil {
		log.WithError(err).Warnf("error when try to check if proto field has field settings")
	}

	// define default values
	if ok {
		msg.Fields = append(msg.Fields, fieldSettings{Field: field, StringRules: stringRule})
	}
}
