package genservice

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/linksoft-dev/single/comps/go/grpc/plugins/service/pb"
	"github.com/linksoft-dev/single/comps/go/tpl"
	pgs "github.com/lyft/protoc-gen-star"
	pgsgo "github.com/lyft/protoc-gen-star/lang/go"
	log "github.com/sirupsen/logrus"
)

//go:embed "template_server.go.tmpl"
var templates embed.FS

// ReportModule creates a report of all the target messages generated by the
// protoc run, writing the file into the /tmp directory.
type reportModule struct {
	*pgs.ModuleBase
	pgsgo.Context
	templatePath string
}

// New configures the module with an instance of ModuleBase
func NewModule() pgs.Module {
	return &reportModule{ModuleBase: &pgs.ModuleBase{}}
}

// Name is the identifier used to identify the module. This value is
// automatically attached to the BuildContext associated with the ModuleBase.
func (m *reportModule) Name() string { return "reporter" }

// Execute is passed the target files as well as its dependencies in the pkgs
// map. The implementation should return a slice of Artifacts that represent
// the files to be generated. In this case, "/tmp/report.txt" will be created
// outside of the normal protoc flow.
func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	buf := &bytes.Buffer{}
	m.templatePath = m.Parameters().StrDefault("path", "./")

	for _, f := range targets {
		m.Push(f.Name().String()).Debug("reporting")
		for i, msg := range f.AllMessages() {
			m.generateValidation(msg, f)
			fmt.Fprintf(buf, "%03d. %v\n", i, msg.Name())
		}
		m.Pop()
	}

	return m.Artifacts()
}

func (m *reportModule) InitContext(c pgs.BuildContext) {
	m.ModuleBase.InitContext(c)
	m.Context = pgsgo.InitContext(c.Parameters())
}

// generateCrud generate the crud file if proto message has crud option set to true
func (m *reportModule) generateValidation(msg pgs.Message, f pgs.File) {
	var v bool
	_, err := msg.Extension(pb.E_Crud, &v)
	if err != nil {
		log.WithError(err).Warnf("error when try to check if message has Crud flag")
	}
	if v == false {
		return
	}

	firestoreFilename := m.Context.OutputPath(f).SetExt(".server.go").String()
	data := struct {
		MessageName string
	}{
		MessageName: msg.Name().String(),
	}
	templateName := "template_server.go.tmpl"
	r, err := tpl.RenderTemplate(templates, templateName, data, nil)
	if err != nil {
		log.WithError(err).Fatalf("failed when render template %s", templateName)
		return
	}

	m.AddGeneratorFile(firestoreFilename, r)
}
